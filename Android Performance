Properly caching networking data is one of the key to good performance. Reading data from device is always faster than reading from network. 
HTTP Caching is disabled by default.
HTTPResponseCache class can be used to turn on the caching of HTTP. Can be used with URLConnection, HTTP or any other library.
If the cache is full, the oldest one would be removed. Cache control system can be used to control which one to delete first. The server in 
this case controls what to delete and what not to.

Networking libraries : Volley , okHTTP , Picasso( image library) 
Network traffic tool in Android studio helps to visualize networking details. Another tool is AT&T's  ARO Tool.

Savvy Cache Management : 
1. Write your own custom disk cache manager
2. Use custom Caching logic

Networking drains the battery the most. Hence syncing regularly for updates is not a good option.
Optimizing Network Request Frequencies:
- Do not over sync. Can drain battery and consume a lot of data(not ideal for monthly data plan people)

Types of Networking Requests
----------------------------
1. Do Now
2. Server request - can delay
3. Data push - can delay

Google Cloud messaging can be used to help the server signal the app when the content has changed.
Back off pattern can be adopted. For instance if queried and nothing to update, next time query ater 2x time, next time 4x and so on.

Can set seek frequency based on user activity. If user is driving, or running or in sleep mode, no need for update. However, if sudden
movement need to update.
Adjust sync frequencies based on state of devices. Can wait for Wifi connection.
Common networking techniques
- Wait for charging
- Wait for wifi
- Batching
- Backoff 
- Wait for active radio

Effective prefetching is one good technique. However, need to prefetch according to connection. In 2G vs 3G the prefetching should be 
different( for instance : 4 MB vs 12 MB perhaps).
GCMNetworkManager API does effective  batching / prefetching.

Adapting to latency - moving from Good connectivity to bad connectivity
1. Gather information - Keep a lookup table of the type of connection and what to fetch ( use ConnectivityManager )
2. Make adjustments

We can check how our app reacts to latency by:
1. Emulator throttling
2. Network attenuator
  
  Minimize Asset Layouts
  ------------------------
  Images and serialized data are the two most bloated types of assets.
  Eg: If transparency is not required, do not use PNG. If not full screen, reduce quality as image as cannot be differentiated.
  Eg. For tablets, apple watches vs phones, use differnt images in server.
  
  User smaller serialized formats. Don't use JSON or XML. Eg: commas, spaces, quotes, carriage return. Use buffers( protobuffs, nanobuffs , flatbuffs).
  
  For different speeds, use different resolutions.
  
  Services : Run in background on UI thread. Services are not free though. Creating, scheduling and destroying of services takes time and memory.
  If possible use Handlers or Asyntask or IntentServivce as they do not work on UI thread.
  
  2 types of Services
  1. Started Services ( runs till stopped): startService() , onStartCommand() , stopSelf(), onDestroy()
  2. Bound services ( runs till all unbind): bindService() , IBinder() , unbindService() , onDestroy()
  Can mix both but the order should be correct, bind(), unbind() and start(), stop()
  
  Systrace tool : Where system time is going
  
  Removing unused code ( make smaller apk) : Tool like ProGuard used to shrink, optimize and obfuscate. Written in gradle. Might
  give false positives for reflection code.
  Remove unused resources( say of third party libraries that are not required in our application) by setting shrinkResources to true in the 
  gradle file.
  
  Culling: Removing things that are not important. Eg: Overdrawing is not good. If database query is to be done, better to prune the
  dataset first based on some filter and then do the searching rather than searching on the whole thing.
  
  Threads in Android help in parallel processing. AsyncTask and Thread both help to stop the program from hanging.
  If thread should affect the UI : AsyncTask ( Eg: ProgressDialog)
  If thread should be hidden : Thread
  
  Batching : Grouping together of identical tasks. If small functions are called repeatedly, they add up to big problem.
  So add up once instead of doing again and again per each instance.Eg: If image is loaded 20 times, then load just once.
  Especially useful for Networking cases. Can be used to draw custom views together
  
  Serialization : Take in memory object and convert into formatted chunk of data( like JSON) that can be converted back to in memory object later on.
  Serialization is everywhere :
  - Sending data between device and server
  - Sending data between 2 processes
  - Storing user preferences to disk
  - Passing the song information to UI to be displayed.
  
  Ways to serialize?
  - Implements Serializable : Bad performance
  - ObjecOutputStream : Bad performance
  
  Better approach is to use GSON library although GSON uses JSON format which produces bloated files.
  Android resources files are compiled at build time so don't have trouble of bloating.
  
  Better options? Use binary serialization forms
  - Google protocol buffers
  - Nano proto buffers
  - FlatBUffers library.
  
  Better not to serialize at times.
  Eg: User preferences can be stored as SharedPreferences( Key , Value) store.
  Parcelable API for sharing between processes
  For structured data, can use SQLite
  
  Ordering of data inside serialization can be very important. 
  Instead of using Array of structures use Structure of Arrays.
  For instance if class has height and width, instead of Array of Class use structure of arrays where array1 = array of height and array2
  is array of width. Due to this compression techniques work better. Eg: Gzip which searches for duplicate strings in a window of 32k
  
  Caching UI data is very important as we might need to load it when the data is being fetched and we do not want to show empty screen
  with spinner.
  
  ArrayMap is better than HashMap if number of objects are lesser or using Map of Map.
  It contains two maps instead of one big one. First contains the hash value and the second the key, value pair corresponding to it.
  Can use binary search. 
  Resizing and Shifting during insertion and deletion might cause problem with ArrayMap. Hence only useful for smaller number of objects.
  
  Autoboxing will take more memory. So use primitives if possible especially when using loops.
  Integer objects take 16 bytes compared to int(4 bytes)
  SparseArray means can use primitives in HashMap
  
  Enums generally take more memory than ints. So avoid Enums. ProGuard generally converts Enums to int to reduce overhead.
  
  
